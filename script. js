const DEFAULT_PROXY_URL = "https://ai-proxy.ai-n.workers.dev/api/generate";
const STORAGE_KEY = "ai_ndraft_data_v2";

const SYSTEM_PROMPT = `You are a helpful AI Document Drafter. You help build documents card by card.

1. VISUAL STYLING (Start of response):
   - Page Theme: !theme:Name,BgHex,CardBgHex,TextHex,BorderHex,PrimaryHex!
   - Card Style: !bg:#hex! !text:#hex! !border:#hex! !pad:px! !radius:px! !bold! !italic!

2. APP ACTIONS (Hidden commands, put at end):
   - !action:merge! (Merges current selection)
   - !action:clear! (Clears the entire board)
   - !action:view:grid! or !action:view:list! or !action:view:full! (Changes view)

3. CARD EDITING:
   - To EDIT the REQUEST: Say "New Request: [text]".
   - To EDIT the RESPONSE: Say "New Response: [text]" or simply provide the improved answer.
   - To STYLE: Use !text:#hex! !bold! etc.

User requests are natural language. You are building a document.`;

class App {
    constructor() {
        this.cards = [];
        this.history = []; 
        this.sessionId = "sess_" + Date.now();
        this.theme = {
            name: 'ai-Ncards',
            primary: '#c41e3a',
            bg: '#121212',
            cardBg: '#1e1e1e',
            text: '#f5f5f5',
            border: '#333',
            locked: false
        };
        this.settings = {
            view: 'list',
            autoTTS: false,
            asrEnabled: false,
            proxyUrl: ''
        };

        this.streamingId = null;
        this.selectedIds = new Set();
        this.contextMenuTargetId = null;
        this.fullscreenId = null;
        this.fsFlipped = false;
        this.editingId = null; 
        this.editingField = null;
        this.stylingId = null; 
        this.promptContext = null; 

        this.recognizer = null;
        this.isListening = false;

        this.decoder = new TextDecoder();
        this.abortController = null;
    }

    async init() {
        this.loadState();
        this.applyTheme();
        this.applyView();
        this.bindEvents();
        this.initASR();
        this.renderAll();
        this.updateToggles();
        
        const proxyInput = document.getElementById('proxyUrlInput');
        if (proxyInput && this.settings.proxyUrl) proxyInput.value = this.settings.proxyUrl;

        document.getElementById('stylePadding').addEventListener('input', (e) => document.getElementById('valPad').textContent = e.target.value + 'px');
        document.getElementById('styleRadius').addEventListener('input', (e) => document.getElementById('valRad').textContent = e.target.value + 'px');
        document.getElementById('styleWidth').addEventListener('input', (e) => document.getElementById('valWid').textContent = e.target.value + 'px');
    }

    getProxyUrl() {
        const inputVal = document.getElementById('proxyUrlInput')?.value.trim();
        if (inputVal) {
            this.settings.proxyUrl = inputVal;
            this.saveState();
            return inputVal;
        }
        return this.settings.proxyUrl || DEFAULT_PROXY_URL;
    }

    bindEvents() {
        const sendBtn = document.getElementById('sendBtn');
        sendBtn.addEventListener('click', () => this.handleSendClick());
        
        const input = document.getElementById('userInput');
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.handleSendClick();
            }
        });

        // --- NEW: Brand Name Tap to Rename ---
        const brandEl = document.getElementById('brandName');
        brandEl.addEventListener('click', () => {
            const newName = prompt("Rename Theme:", this.theme.name || "ai-Ncards");
            if (newName && newName.trim()) {
                this.pushHistory("Rename Theme");
                this.theme.name = newName.trim();
                this.applyTheme();
                this.saveState();
            }
        });

        document.getElementById('menuFab').addEventListener('click', () => this.openModal('settingsModal'));
        document.getElementById('viewFab').addEventListener('click', () => this.cycleView());
        document.getElementById('undoFabTop').addEventListener('click', () => this.undo());

        document.getElementById('cancelSelect').addEventListener('click', () => this.clearSelection());
        document.getElementById('mergeSelected').addEventListener('click', () => this.promptAction('merge'));
        document.getElementById('deleteSelected').addEventListener('click', () => this.bulkDelete());
        document.getElementById('splitSelected').addEventListener('click', () => this.promptAction('split'));

        document.getElementById('cardMenu').addEventListener('click', (e) => {
            const btn = e.target.closest('.menu-item');
            if (btn && this.contextMenuTargetId) {
                const action = btn.dataset.action;
                if (action === 'undo') {
                    this.undo();
                } else {
                    this.handleCardAction(action, this.contextMenuTargetId);
                }
                this.closeCardMenu();
            }
        });

        document.querySelectorAll('.modal-overlay').forEach(overlay => {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    const id = overlay.id;
                    this.closeModal(id);
                }
            });
        });

        document.getElementById('promptConfirmBtn').addEventListener('click', () => this.executePromptAction());

        document.addEventListener('click', (e) => {
            if (!e.target.closest('#cardMenu') && !e.target.closest('.card-actions') && !e.target.closest('.flip-card')) {
                this.closeCardMenu();
            }
        });
    }

    saveState() {
        const data = {
            cards: this.cards,
            theme: this.theme,
            settings: this.settings,
            sessionId: this.sessionId
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }

    loadState() {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
            try {
                const data = JSON.parse(raw);
                this.cards = data.cards || [];
                this.theme = { ...this.theme, ...data.theme };
                this.settings = { ...this.settings, ...data.settings };
                this.sessionId = data.sessionId || this.sessionId;
            } catch (e) {
                console.error("Load failed", e);
            }
        }
    }

    pushHistory(actionType) {
        if (this.history.length > 10) this.history.shift();
        this.history.push({
            cards: JSON.parse(JSON.stringify(this.cards)),
            theme: { ...this.theme },
            timestamp: Date.now(),
            action: actionType
        });
        this.showToast(`Saved: ${actionType}`);
    }

    undo() {
        if (this.history.length === 0) {
            this.showToast("Nothing to undo");
            return;
        }
        const lastState = this.history.pop();
        this.cards = lastState.cards;
        if (!this.theme.locked) this.theme = lastState.theme;
        
        this.saveState();
        this.renderAll();
        this.applyTheme();
        this.showToast("Undid: " + lastState.action);
    }

    exportData() {
        const data = {
            cards: this.cards,
            theme: this.theme,
            settings: this.settings,
            sessionId: this.sessionId
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `ai_ncards_export_${Date.now()}.json`;
        a.click();
        this.showToast("Export downloaded");
    }

    importData(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                this.pushHistory("Pre-Import Backup");
                this.cards = data.cards || [];
                this.theme = data.theme || this.theme;
                this.settings = data.settings || this.settings;
                this.sessionId = data.sessionId || this.sessionId;
                
                this.renderAll();
                this.applyTheme();
                this.applyView();
                this.saveState();
                this.showToast("Import Successful");
                this.closeModal('settingsModal');
            } catch (err) {
                alert("Invalid JSON file");
            }
        };
        reader.readAsText(file);
        input.value = ''; 
    }

    clearAll() {
        if (confirm("Are you sure you want to delete ALL cards? This cannot be undone.")) {
            this.pushHistory("Clear All");
            this.cards = [];
            this.saveState();
            this.renderAll();
            this.closeModal('settingsModal');
            this.showToast("Grid Cleared");
        }
    }

    resetApp() {
        if (confirm("WARNING: This will delete ALL data, settings, and history. The app will restart to the welcome screen. Are you sure?")) {
            localStorage.removeItem(STORAGE_KEY);
            window.location.reload();
        }
    }

    addCard(q, r, styles = {}) {
        const id = crypto.randomUUID();
        const card = { id, q, r, styles };
        this.cards.push(card);
        this.pushHistory("Add Card");
        this.renderCard(card, true);
        return id;
    }

    deleteCard(id) {
        this.cards = this.cards.filter(c => c.id !== id);
        const el = document.querySelector(`.flip-card[data-id="${id}"]`);
        if (el) el.remove();
        if (this.fullscreenId === id) this.closeFullscreen();
        this.saveState();
    }

    updateCardContent(id, q, r) {
        const card = this.cards.find(c => c.id === id);
        if (!card) return;
        if (q !== null) card.q = q;
        if (r !== null) card.r = r;
        
        const el = document.querySelector(`.flip-card[data-id="${id}"]`);
        if (el) {
            if (q !== null) el.querySelector('.card-face:first-child .content').innerHTML = this.md(q);
            if (r !== null) {
                const rEl = el.querySelector('.response-content');
                if (rEl) rEl.innerHTML = this.md(r);
            }
        }
        this.saveState();
    }

    renderAll() {
        const grid = document.getElementById('grid');
        const empty = document.getElementById('emptyState');
        grid.innerHTML = '';
        
        if (this.cards.length === 0) {
            grid.appendChild(empty);
            empty.style.display = 'flex';
        } else {
            empty.style.display = 'none';
            this.cards.forEach(c => this.renderCard(c, false));
        }
    }

    renderCard(card, isNew) {
        const grid = document.getElementById('grid');
        const empty = document.getElementById('emptyState');
        if (empty && empty.parentNode) empty.remove();

        const div = document.createElement('div');
        div.className = `flip-card ${isNew ? 'new' : ''}`;
        div.dataset.id = card.id;
        div.tabIndex = 0;
        
        if (card.styles && card.styles.locked) {
            div.classList.add('locked');
        }

        let rHtml;
        if (card.r === '...') {
            if (this.streamingId === card.id) {
                rHtml = '<div class="streaming"><span class="thinking-indicator">Thinking...</span><button class="stop-stream-btn" onclick="app.stopStream()">Stop</button></div>';
            } else {
                rHtml = '<div class="streaming"><span class="thinking-indicator">Thinking...</span></div>';
            }
        } else {
            rHtml = this.md(card.r);
        }

        div.innerHTML = `
            <div class="flip-card-inner">
                <div class="card-face" data-face="front">
                    <div class="card-header">
                        <span style="font-size:11px; opacity:0.5;">REQ (Double Tap to Edit)</span>
                        <div class="card-actions">
                            <button onclick="app.openCardMenu('${card.id}', event)"><i class="fas fa-ellipsis-v"></i></button>
                            <button onclick="app.toggleSelect('${card.id}', event)"><i class="fas fa-check-circle"></i></button>
                        </div>
                    </div>
                    <div class="content">${this.md(card.q)}</div>
                </div>
                <div class="card-face card-back" data-face="back">
                    <div class="card-header">
                        <span style="font-size:11px; opacity:0.5;">RESPONSE</span>
                        <div class="card-actions">
                            <button onclick="app.readCard('${card.id}', event)"><i class="fas fa-volume-up"></i></button>
                            <button onclick="app.openCardMenu('${card.id}', event)"><i class="fas fa-ellipsis-v"></i></button>
                        </div>
                    </div>
                    <div class="response-content">${rHtml}</div>
                </div>
            </div>
        `;

        if (card.styles) this.applyCardStyleToEl(div, card.styles);

        this.attachCardEvents(div, card.id);
        grid.appendChild(div);
    }

    attachCardEvents(div, id) {
        // 1. Single Tap / Click
        div.addEventListener('click', (e) => {
            if (e.target.closest('button') || e.target.closest('.card-actions')) return;
            if (this.selectedIds.size > 0) {
                e.stopPropagation();
                this.toggleSelect(id, e);
                return;
            }
            
            // Don't flip if we just edited
            if (div.dataset._justEdited === 'true') {
                div.dataset._justEdited = 'false';
                return;
            }

            div.classList.toggle('flipped');
        });

        // 2. Double Tap (Edit Request)
        div.addEventListener('dblclick', (e) => {
            if (e.target.closest('button') || e.target.closest('.card-actions')) return;
            
            // Check if we are on the Front face
            const inner = div.querySelector('.flip-card-inner');
            const isFlipped = div.classList.contains('flipped');
            
            if (!isFlipped) {
                // We are on the Request side. Edit it.
                e.preventDefault();
                e.stopPropagation();
                this.editingId = id;
                this.editingField = 'q';
                const card = this.cards.find(c => c.id === id);
                this.openEditor(card.q, "Edit Request");
                // Set flag to prevent the single click 'flip' trigger from firing immediately after this
                div.dataset._justEdited = 'true';
            }
        });

        // 3. Long Press (Context Menu)
        let lastTap = 0;
        let pressTimer;
        
        div.addEventListener('touchstart', (e) => {
            if (this.selectedIds.size > 0) return;
            
            // Short tap detection for flip is handled by click event, but we need to distinguish from long press
            pressTimer = setTimeout(() => {
                // Long press triggered
                this.openCardMenu(id, e);
                if (navigator.vibrate) navigator.vibrate(50);
                pressTimer = null;
            }, 450); // Slightly longer than double tap speed
        });

        div.addEventListener('touchend', (e) => {
            if (pressTimer) {
                clearTimeout(pressTimer); // It was a short tap
                // The click event will handle the flip
            }
        });
        
        div.addEventListener('touchmove', () => {
            if (pressTimer) {
                clearTimeout(pressTimer);
                pressTimer = null;
            }
        });

        div.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') div.classList.toggle('flipped');
            if (e.key === ' ' && e.shiftKey) {
                e.preventDefault();
                this.openCardMenu(id);
            }
        });
    }

    handleSendClick() {
        const input = document.getElementById('userInput');
        const val = input.value.trim();
        if (!val) return;

        if (this.isListening) {
            this.recognition.stop();
            return;
        }

        if (this.settings.asrEnabled && this.recognizer) {
            this.recognition.start();
            return;
        }

        this.sendRequest(val);
        input.value = '';
    }

    scrollToStreamingContent(element) {
        if (!element) return;
        const isNearBottom = (element.scrollHeight - element.scrollTop - element.clientHeight) < 150;
        if (isNearBottom) {
            element.scrollTop = element.scrollHeight;
        }
    }

    async sendRequest(prompt, contextCardId = null) {
        this.streamingId = contextCardId ? contextCardId : this.addCard(prompt, '...', {});
        
        const cardEl = document.querySelector(`.flip-card[data-id="${this.streamingId}"]`);
        if(cardEl && !contextCardId) setTimeout(() => cardEl.classList.add('flipped'), 100);

        let fullPrompt = SYSTEM_PROMPT + "\n\nUser: " + prompt;
        if (contextCardId) {
            const oldCard = this.cards.find(c => c.id === contextCardId);
            if (oldCard) {
                fullPrompt = `PREVIOUS STATE:\nRequest: "${oldCard.q}"\nResponse: "${oldCard.r}"\n\nNEW INSTRUCTIONS:\n${prompt}\n\nPlease refine the card based on instructions. If you want to change the Request, say "New Request: ...". If you want to change the Response, say "New Response: ..." or provide the new text.`;
            }
        }

        this.abortController = new AbortController();
        const signal = this.abortController.signal;

        try {
            const url = this.getProxyUrl();
            const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sessionId: this.sessionId, prompt: fullPrompt }),
                signal
            });

            if (!res.ok) throw new Error(`Proxy Error: ${res.status}`);

            const reader = res.body.getReader();
            let buffer = '';
            let accumulated = '';
            let isFirstChunk = true;

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                buffer += this.decoder.decode(value, { stream: true });
                
                const lines = buffer.split('\n\n');
                buffer = lines.pop() || '';
                for (const line of lines) {
                    const jsonStr = line.replace('data: ', '').trim();
                    if (!jsonStr || jsonStr === '[DONE]') continue;
                    try {
                        const json = JSON.parse(jsonStr);
                        const chunk = json.choices?.[0]?.delta?.content;
                        if (chunk) {
                            accumulated += chunk;
                            if (isFirstChunk) {
                                this.updateStreamingContent(accumulated, true);
                                isFirstChunk = false;
                            } else {
                                this.updateStreamingContent(accumulated, false);
                            }
                        }
                    } catch {}
                }
            }

            this.finalizeResponse(accumulated);

        } catch (err) {
            if (err.name === 'AbortError') {
                const el = document.querySelector(`.flip-card[data-id="${this.streamingId}"] .response-content`);
                if (el) el.innerHTML += '<div style="color:#ff6b6b; margin-top:10px;">[Stopped]</div>';
            } else {
                const el = document.querySelector(`.flip-card[data-id="${this.streamingId}"] .response-content`);
                if (el) el.innerHTML = `<span style="color: #ff6b6b; font-weight: bold;">Error: ${err.message}</span>`;
            }
            this.streamingId = null;
        } finally {
            this.abortController = null;
        }
    }

    stopStream() {
        if (this.abortController) {
            this.abortController.abort();
            this.abortController = null;
            this.showToast("Streaming stopped");
        }
    }

    updateStreamingContent(text, replace = false) {
        if (!this.streamingId) return;
        const visible = text.replace(/![^!]+!/g, '');
        
        const el = document.querySelector(`.flip-card[data-id="${this.streamingId}"] .response-content`);
        if (el) {
            if (replace) {
                el.innerHTML = this.md(visible);
            } else {
                el.innerHTML = this.md(visible) + '<div class="streaming"><span class="cursor"></span></div>';
            }
            this.scrollToStreamingContent(el);
        }

        if (this.fullscreenId === this.streamingId) {
            const fsPane = document.getElementById('fsResponsePane');
            if (fsPane) {
                if (replace) {
                    document.getElementById('fsResponse').innerHTML = this.md(visible);
                } else {
                    document.getElementById('fsResponse').innerHTML = this.md(visible) + '<div class="streaming"><span class="cursor"></span></div>';
                }
                this.scrollToStreamingContent(fsPane);
            }
        }
    }

    finalizeResponse(fullText) {
        const id = this.streamingId;
        if (!id) return;

        const { cleanText, styles, themeUpdate, actions } = this.parseCommands(fullText);
        const card = this.cards.find(c => c.id === id);
        
        if (card) {
            let newQ = null;
            let newR = null;
            
            const reqMatch = cleanText.match(/New Request:\s*(.+)/i);
            const respMatch = cleanText.match(/New Response:\s*(.+)/i);

            if (reqMatch) {
                newQ = reqMatch[1].trim();
            }
            if (respMatch) {
                newR = respMatch[1].trim();
            }

            if (newQ) {
                card.q = newQ;
                if (!newR) newR = card.r; 
            }
            
            if (newR) {
                card.r = newR;
            }

            if (!newQ && !newR) {
                 if (card.styles && card.styles.locked) {
                    this.showToast("Card Locked - Style changes ignored");
                } else {
                    if (Object.keys(styles).length > 0) {
                        card.styles = { ...card.styles, ...styles };
                    }
                }
                if (cleanText) card.r = cleanText;
            }

            if (newQ) {
                card.q = newQ;
            }
        }

        const finalDisplayText = card ? card.r : cleanText; 
        const cleanHtml = this.md(finalDisplayText);
        
        const el = document.querySelector(`.flip-card[data-id="${id}"] .response-content`);
        if (el) el.innerHTML = cleanHtml;

        if (this.fullscreenId === id) {
            document.getElementById('fsResponse').innerHTML = cleanHtml;
            const fsPane = document.getElementById('fsResponsePane');
            if (fsPane) fsPane.scrollTop = fsPane.scrollHeight;
        }

        if (card && card.q) {
            const qEl = document.querySelector(`.flip-card[data-id="${id}"] .card-face:first-child .content`);
            if (qEl) qEl.innerHTML = this.md(card.q);
        }

        if (card && (!card.styles || !card.styles.locked)) {
            if (Object.keys(styles).length > 0 && !this.theme.locked) {
                const cardEl = document.querySelector(`.flip-card[data-id="${id}"]`);
                if (cardEl) this.applyCardStyleToEl(cardEl, styles);
            }
        }

        if (themeUpdate) {
            if (this.theme.locked) {
                this.showToast("Global Theme Locked");
            } else {
                this.theme = { ...this.theme, ...themeUpdate };
                this.applyTheme();
                this.saveState();
                this.showToast(`Theme: ${themeUpdate.name || 'Updated'}`);
            }
        }

        if (actions.length > 0) {
            actions.forEach(action => {
                if (action === 'clear') this.clearAll();
                if (action === 'merge') {
                     if (this.selectedIds.size > 1) {
                         this.merge();
                     } else {
                         this.showToast("AI requested merge, but no cards selected.");
                     }
                }
                if (action.startsWith('view:')) {
                    const view = action.split(':')[1];
                    if (['list', 'grid', 'full'].includes(view)) {
                        this.setCardView(view);
                        this.showToast(`AI switched to ${view}`);
                    }
                }
            });
        }

        if (this.settings.autoTTS) this.readCard(id);

        this.streamingId = null;
        this.pushHistory("AI Response");
    }

    parseCommands(text) {
        const cmdRegex = /!(theme|bg|text|border|pad|radius|font|bold|italic|css|action):?([^!]+)!/gi;
        let styles = {};
        let actions = [];
        let themeUpdate = null;
        let match;
        let safeText = text;

        while ((match = cmdRegex.exec(text)) !== null) {
            const type = match[1].toLowerCase();
            const val = match[2].trim();

            if (type === 'theme') {
                const [name, bg, cardBg, textC, border, primary] = val.split(',').map(s => s.trim());
                themeUpdate = { name, bg, cardBg, text: textC, border, primary };
            } else if (type === 'bg') styles.backgroundColor = val;
            else if (type === 'text') styles.color = val;
            else if (type === 'border') styles.borderColor = val;
            else if (type === 'pad') styles.padding = val.endsWith('px') ? val : val + 'px';
            else if (type === 'radius') styles.borderRadius = val.endsWith('px') ? val : val + 'px';
            else if (type === 'font') styles.fontSize = val.endsWith('px') ? val : val + 'px';
            else if (type === 'bold') styles.fontWeight = 'bold';
            else if (type === 'italic') styles.fontStyle = 'italic';
            else if (type === 'css') styles.customCSS = val;
            else if (type === 'action') actions.push(val);

            safeText = safeText.replace(match[0], '');
        }

        return { cleanText: safeText.trim(), styles, themeUpdate, actions };
    }

    applyCardStyleToEl(el, styles) {
        const face = el.querySelectorAll('.card-face');
        face.forEach(f => {
            if (styles.color) f.style.color = styles.color;
            if (styles.backgroundColor) f.style.backgroundColor = styles.backgroundColor;
            if (styles.fontSize) f.style.fontSize = styles.fontSize;
            if (styles.fontWeight) f.style.fontWeight = styles.fontWeight;
            if (styles.fontStyle) f.style.fontStyle = styles.fontStyle;
            if (styles.padding) f.style.padding = styles.padding;
        });
        
        if (styles.borderColor) el.style.borderColor = styles.borderColor;
        if (styles.borderRadius) el.style.borderRadius = styles.borderRadius;
        
        if (styles.customCSS) {
            const id = `style-${el.dataset.id}`;
            let styleTag = document.getElementById(id);
            if (!styleTag) {
                styleTag = document.createElement('style');
                styleTag.id = id;
                document.head.appendChild(styleTag);
            }
            styleTag.textContent = `[data-id="${el.dataset.id}"] ${styles.customCSS}`;
        }
    }

    openCardMenu(id, e) {
        if (e && e.preventDefault) e.preventDefault();
        if (e && e.stopPropagation) e.stopPropagation();
        
        this.contextMenuTargetId = id;
        const menu = document.getElementById('cardMenu');
        
        let x, y;
        if (e && e.clientX) {
            x = e.clientX;
            y = e.clientY;
        } else if (e && e.touches && e.touches[0]) {
            x = e.touches[0].clientX;
            y = e.touches[0].clientY;
        } else {
            const el = document.querySelector(`.flip-card[data-id="${id}"]`);
            if (el) {
                const rect = el.getBoundingClientRect();
                x = rect.left + rect.width / 2;
                y = rect.top + rect.height / 2;
            } else {
                x = window.innerWidth / 2;
                y = window.innerHeight / 2;
            }
        }

        if (x + 200 > window.innerWidth) x = window.innerWidth - 210;
        if (y + 350 > window.innerHeight) y = window.innerHeight - 360;

        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;
        menu.classList.add('active');
    }

    closeCardMenu() {
        document.getElementById('cardMenu').classList.remove('active');
        this.contextMenuTargetId = null;
    }

    handleCardAction(action, id) {
        const card = this.cards.find(c => c.id === id);
        if (!card) return;

        switch (action) {
            case 'continue': this.promptAction('continue', id); break;
            case 'split': this.promptAction('split', id); break;
            case 'merge':
                if (!this.selectedIds.has(id)) {
                    this.selectedIds.add(id);
                    const el = document.querySelector(`.flip-card[data-id="${id}"]`);
                    if (el) el.classList.add('selected');
                }
                if (this.selectedIds.size < 2) {
                    this.showToast("Need at least 2 cards to merge");
                    this.updateSelectionUI();
                    return;
                }
                this.updateSelectionUI();
                this.promptAction('merge');
                break;