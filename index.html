<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ai-Ntile Pro</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    :root {
      --primary: #c41e3a;
      --bg: #121212;
      --card-bg: #1e1e1e;
      --text: #f5f5f5;
      --border: #333;
      --radius: 12px;
      --safe-area-bottom: env(safe-area-inset-bottom);
    }
    body { margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, sans-serif; height: 100vh; overflow: hidden; display: flex; flex-direction: column; transition: background 0.3s, color 0.3s; }

    /* Header */
    #topBar { height: 45px; display: flex; justify-content: space-between; align-items: center; padding: 0 15px; border-bottom: 1px solid var(--border); background: var(--bg); z-index: 10; }
    #brandName { font-weight: 1200; color: var(--primary); text-transform: lowercase; letter-spacing: 1px; cursor: pointer; font-size: 12px; }
    .btn-icon { background: rgba(128, 128, 128, 0.1); border: 1px solid var(--border); color: var(--text); width: 32px; height: 32px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; margin-left: 5px; }
    .btn-icon:hover { background: rgba(128, 128, 128, 0.2); }

    /* Selection Bar */
    #selectionBar { background: var(--primary); color: white; display: none; justify-content: space-between; align-items: center; padding: 5px 10px; height: 40px; font-size: 13px; font-weight: bold; }
    #selectionBar .actions button { background: rgba(0, 0, 0, 0.2); border: none; color: white; padding: 4px 8px; border-radius: 4px; margin-left: 5px; cursor: pointer; }
    #selectionBar .actions button.danger { background: #b71c1c; }

    /* Main Grid */
    #grid {
      flex: 1; overflow-y: auto; padding: 15px; 
      display: grid; gap: 15px; align-content: start; 
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      scroll-behavior: smooth; 
    }
    body.view-list #grid { grid-template-columns: 1fr; }

    /* Card */
    .flip-card {
      background-color: var(--card-bg);
      height: 220px;
      perspective: 1000px;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      cursor: pointer;
      position: relative;
      display: flex; flex-direction: column;
      transition: transform 0.2s;
    }
    .flip-card-inner {
      position: relative; width: 100%; height: 100%;
      text-align: left; transition: transform 0.6s; transform-style: preserve-3d;
    }
    .flip-card.flipped .flip-card-inner { transform: rotateY(180deg); }
    .flip-card-face {
      position: absolute; width: 100%; height: 100%;
      -webkit-backface-visibility: hidden; backface-visibility: hidden;
      overflow: hidden; display: flex; flex-direction: column;
      border-radius: var(--radius); padding: 0;
    }
    .front { background: linear-gradient(145deg, var(--card-bg), var(--bg)); }
    .back { background: linear-gradient(145deg, var(--bg), var(--card-bg)); transform: rotateY(180deg); }

    .card-header {
      padding: 8px 12px; font-size: 10px; text-transform: uppercase; color: #888;
      border-bottom: 1px solid var(--border); display: flex; justify-content: space-between;
      background: rgba(0,0,0,0.1); height: 22px; align-items: center;
    }
    .card-content {
      padding: 10px; font-size: 14px; line-height: 1.4; overflow-y: auto; flex: 1; white-space: pre-wrap; font-weight: 500; word-break: break-word;
    }
    .back .card-content { font-family: monospace; font-size: 13px; }
    .card-actions i { opacity: 0.6; margin-left: 6px; cursor: pointer; transition: 0.2s; font-size: 11px; }
    .card-actions i:hover { opacity: 1; color: var(--primary); }

    /* Input */
    #inputPanel { padding: 35px; background: var(--bg); border-top: 1px solid var(--border); display: flex; gap: 8px; align-items: center; padding-bottom: calc(45px + var(--safe-area-bottom)); }
    #userInput { flex: 1; background: rgba(128, 128, 128, 0.1); border: 1px solid var(--border); color: var(--text); padding: 10px; border-radius: 20px; height: 40px; outline: none; }
    #userInput:focus { border-color: var(--primary); }
    #sendBtn { background: var(--primary); border: none; color: white; width: 40px; height: 40px; border-radius: 50%; font-weight: bold; cursor: pointer; font-size: 16px; }

    /* Menu */
    #cardMenu { position: fixed; display: none; background: var(--card-bg); border: 1px solid var(--border); border-radius: 8px; z-index: 1000; box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3); min-width: 180px; overflow: hidden; }
    #cardMenu button { display: block; width: 100%; background: none; border: none; color: var(--text); padding: 10px 15px; text-align: left; cursor: pointer; font-size: 13px; border-bottom: 1px solid var(--border); }
    #cardMenu button:hover { background: rgba(128, 128, 128, 0.1); }
    #cardMenu button:last-child { border-bottom: none; color: #ff6b6b; }

    /* Modals */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); display: none; justify-content: center; align-items: center; z-index: 2000; backdrop-filter: blur(2px); }
    .modal { background: var(--card-bg); width: 90%; max-width: 500px; max-height: 80vh; border-radius: 12px; border: 1px solid var(--border); display: flex; flex-direction: column; box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5); }
    .modal-header { padding: 15px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
    .modal-body { padding: 15px; overflow-y: auto; flex: 1; }
    .modal-footer { padding: 15px; border-top: 1px solid var(--border); text-align: right; display: flex; justify-content: flex-end; gap: 10px; }
    .modal input[type="text"], .modal textarea, .modal select { width: 100%; background: rgba(128, 128, 128, 0.1); border: 1px solid var(--border); color: var(--text); padding: 10px; border-radius: 6px; margin-bottom: 10px; font-family: inherit; }
    .modal textarea { min-height: 100px; resize: vertical; }
    .btn { padding: 8px 16px; border-radius: 6px; border: none; cursor: pointer; font-weight: bold; font-size: 13px; }
    .btn-primary { background: var(--primary); color: white; }
    .btn-secondary { background: rgba(128, 128, 128, 0.2); color: var(--text); border: 1px solid var(--border); }
    
    /* Settings */
    .setting-row { margin-bottom: 15px; border-bottom: 1px solid #333; padding-bottom: 10px; }
    .setting-row label { display: block; margin-bottom: 5px; color: #888; font-size: 12px; text-transform: uppercase; }
    .toggle-group { display: flex; gap: 5px; flex-wrap: wrap; }
    .toggle-btn { background: rgba(128, 128, 128, 0.1); border: 1px solid var(--border); color: var(--text); padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 11px; }
    .toggle-btn.active { background: var(--primary); color: white; border-color: var(--primary); }
    .btn-danger { background: #b71c1c; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold; width: 100%; margin-top: 5px; }

    /* Fullscreen */
    #fullscreenOverlay { position: fixed; inset: 0; background: var(--bg); z-index: 3000; display: none; flex-direction: column; }
    #fsContent { flex: 1; overflow-y: auto; padding: 20px; font-size: 18px; line-height: 1.6; scroll-behavior: smooth; }
    #fsHeader { padding: 10px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; background: var(--card-bg); }

    /* Toast */
    #toast { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background: var(--primary); color: white; padding: 8px 16px; border-radius: 20px; font-size: 12px; opacity: 0; transition: 0.3s; pointer-events: none; }
    #toast.show { opacity: 1; bottom: 90px; }

    /* Streaming */
    .cursor { display: inline-block; width: 2px; height: 1em; background: var(--primary); animation: blink 1s infinite; vertical-align: middle; }
    @keyframes blink { 50% { opacity: 0; } }
    .stop-btn { background: #b71c1c; color: white; border: none; padding: 2px 6px; border-radius: 3px; font-size: 10px; cursor: pointer; margin-left: 5px; }

    /* AI Options Modal */
    .ai-option { background: rgba(128, 128, 128, 0.1); border: 1px solid var(--border); border-radius: 6px; padding: 10px; margin: 8px 0; cursor: pointer; transition: 0.2s; }
    .ai-option:hover { background: rgba(128, 128, 128, 0.2); border-color: var(--primary); }
    .ai-option-title { font-weight: bold; color: var(--primary); margin-bottom: 4px; }
    .ai-option-desc { font-size: 11px; color: #888; }

    @media (max-width: 600px) {
      #grid { grid-template-columns: 1fr !important; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/responsivevoice@1.0.0/responsivevoice.min.js"></script>
</head>
<body>
  <script>
    class App {
      constructor() {
        const defaultState = {
          cards: [],
          theme: { name: "ai-Ncards", bg: "#121212", cardBg: "#1e1e1e", text: "#f5f5f5", border: "#333333", primary: "#c41e3a", lock: false },
          settings: { proxy: "", view: "list" },
          favoriteThemes: []  // NEW: Store favorite themes
        };
        
        const saved = localStorage.getItem('ai_ncards_v2');
        if (saved) {
          this.state = JSON.parse(saved);
          this.state.theme = { ...defaultState.theme, ...this.state.theme };
          this.state.settings = { ...defaultState.settings, ...this.state.settings };
          if (!Array.isArray(this.state.cards)) this.state.cards = [];
          if (!Array.isArray(this.state.favoriteThemes)) this.state.favoriteThemes = [];
        } else {
          this.state = defaultState;
        }
        
        this.streamId = null;
        this.selected = new Set();
        this.menuTarget = null;
        this.fsId = null;
        this.fsFlipped = false;
        this.promptContext = null;
        this.history = [];
        this.decoder = new TextDecoder();
      }

      init() {
        this.applyTheme();
        this.render();
        this.bindEvents();
      }

      save() { 
        localStorage.setItem('ai_ncards_v2', JSON.stringify(this.state)); 
      }

      // ========== IMPROVED AI FEATURES ==========

      // 1. Enhanced Merge with AI Suggestions
      async aiMergeSuggestions() {
        if (this.selected.size < 2) return this.showToast("Select 2+ cards");
        
        const selectedCards = this.state.cards.filter(c => this.selected.has(c.id));
        const combined = selectedCards.map(c => `Card "${c.q}": ${c.r.substring(0, 200)}`).join('\n\n');
        
        const prompt = `You are an expert content strategist. I want to merge ${this.selected.size} cards into one cohesive card. Here are the cards:\n\n${combined}\n\nPlease suggest 3 different ways to merge these cards. For each suggestion, provide:\n1. A title/topic for the merged card\n2. A brief description of the merging approach\n3. The key points to include\n\nFormat each suggestion as: "Option X: [Title] | [Description] | [Key Points]"`;
        
        const id = crypto.randomUUID();
        this.state.cards.push({ id, q: "AI Merge Suggestions", r: "...", style: {} });
        this.save(); this.render();
        
        setTimeout(() => {
          const el = document.querySelector(`.flip-card[data-id="${id}"]`);
          if(el) el.classList.add('flipped');
        }, 100);
        
        this.sendRequest(prompt, id);
      }

      // 2. Split Card with AI Options
      async aiSplitSuggestions(cardId) {
        const card = this.state.cards.find(c => c.id === cardId);
        if (!card) return;
        
        const prompt = `You are an expert at organizing information. Please analyze this card content and suggest 3 different ways to split it into multiple cards:\n\n"${card.q}"\n\nContent: ${card.r.substring(0, 500)}\n\nFor each splitting suggestion, provide:\n1. Number of resulting cards\n2. Titles/topics for each split card\n3. Brief description of what content goes where\n4. The splitting logic\n\nFormat each suggestion as: "Split Option X: [Number of Cards] | [Titles] | [Description] | [Logic]"`;
        
        const id = crypto.randomUUID();
        this.state.cards.push({ id, q: "AI Split Suggestions", r: "...", style: {} });
        this.save(); this.render();
        
        setTimeout(() => {
          const el = document.querySelector(`.flip-card[data-id="${id}"]`);
          if(el) el.classList.add('flipped');
        }, 100);
        
        this.sendRequest(prompt, id);
      }

      // 3. Execute AI Merge with chosen option
      async executeAiMerge(mergeType = "cohesive") {
        if (this.selected.size < 2) return;
        
        const selectedCards = this.state.cards.filter(c => this.selected.has(c.id));
        const combined = selectedCards.map(c => `Card: "${c.q}" - ${c.r}`).join('\n\n');
        
        const strategies = {
          cohesive: "Create one cohesive, well-structured card that combines all key points in a logical flow",
          summary: "Create a summary card that extracts the most important points from each card",
          thematic: "Group cards by themes and create a card that organizes content thematically",
          comparative: "Create a comparative analysis card that contrasts and compares the different cards"
        };
        
        const strategy = strategies[mergeType] || strategies.cohesive;
        const prompt = `${strategy} based on these cards:\n\n${combined}\n\nProvide a clear title and comprehensive content.`;
        
        const id = crypto.randomUUID();
        this.state.cards.push({ id, q: "Merged Result", r: "...", style: {} });
        this.save(); this.render();
        
        setTimeout(() => {
          const el = document.querySelector(`.flip-card[data-id="${id}"]`);
          if(el) el.classList.add('flipped');
        }, 100);
        
        this.sendRequest(prompt, id);
        this.selected.clear();
      }

      // 4. Execute AI Split with chosen option
      async executeAiSplit(cardId, splitStrategy = "by_topic") {
        const card = this.state.cards.find(c => c.id === cardId);
        if (!card) return;
        
        const strategies = {
          by_topic: "Split by different topics/subjects mentioned",
          chronological: "Split chronologically or by sequence",
          by_importance: "Split by importance level (main points vs details)",
          question_based: "Split into question-answer pairs",
          pros_cons: "Split into pros/cons or advantages/disadvantages"
        };
        
        const strategy = strategies[splitStrategy] || "by topic";
        const prompt = `Split the following card content into multiple cards using this strategy: ${strategy}.\n\nOriginal Card: "${card.q}"\n\nContent: ${card.r}\n\nFor each resulting card, provide:\n- A clear title/topic\n- The content for that card\n\nSeparate each card with "---CARD---" and format as "Title: [title]\nContent: [content]"`;
        
        const id = crypto.randomUUID();
        this.state.cards.push({ id, q: `Split Results (${strategy})`, r: "...", style: {} });
        this.save(); this.render();
        
        setTimeout(() => {
          const el = document.querySelector(`.flip-card[data-id="${id}"]`);
          if(el) el.classList.add('flipped');
        }, 100);
        
        // Custom handling for split results
        this.sendRequestForSplit(prompt, id, cardId);
      }

      // 5. Save Current Theme as Favorite
      saveCurrentThemeAsFavorite(name = null) {
        if (!name) {
          this.promptContext = { type: 'saveTheme' };
          this.showPromptModal("Save Theme as Favorite", this.state.theme.name || "My Theme");
          return;
        }
        
        const themeCopy = { ...this.state.theme };
        themeCopy.savedName = name;
        themeCopy.savedAt = new Date().toISOString();
        
        // Check if theme with same colors exists
        const existingIndex = this.state.favoriteThemes.findIndex(t => 
          t.bg === themeCopy.bg && 
          t.cardBg === themeCopy.cardBg && 
          t.text === themeCopy.text && 
          t.primary === themeCopy.primary
        );
        
        if (existingIndex >= 0) {
          this.state.favoriteThemes[existingIndex] = themeCopy;
          this.showToast("Theme updated in favorites");
        } else {
          this.state.favoriteThemes.push(themeCopy);
          this.showToast("Theme saved to favorites");
        }
        
        this.save();
        this.renderFavoriteThemes();
      }

      // 6. Apply Favorite Theme
      applyFavoriteTheme(index) {
        if (this.state.theme.lock) {
          this.showToast("Theme Locked");
          return;
        }
        
        if (index >= 0 && index < this.state.favoriteThemes.length) {
          const favTheme = this.state.favoriteThemes[index];
          this.state.theme = { 
            ...this.state.theme, 
            name: favTheme.savedName || favTheme.name,
            bg: favTheme.bg,
            cardBg: favTheme.cardBg,
            text: favTheme.text,
            border: favTheme.border,
            primary: favTheme.primary,
            lock: false
          };
          this.applyTheme();
          this.save();
          this.showToast(`Applied: ${favTheme.savedName || favTheme.name}`);
        }
      }

      // 7. Delete Favorite Theme
      deleteFavoriteTheme(index) {
        if (index >= 0 && index < this.state.favoriteThemes.length) {
          this.state.favoriteThemes.splice(index, 1);
          this.save();
          this.renderFavoriteThemes();
          this.showToast("Theme removed from favorites");
        }
      }

      // 8. Enhanced Export Function
      exportData(format = 'full') {
        const exportData = {
          version: '2.0',
          exportedAt: new Date().toISOString(),
          app: 'ai-Ncards Pro'
        };
        
        if (format === 'full') {
          exportData.data = this.state;
        } else if (format === 'cards_only') {
          exportData.cards = this.state.cards;
          exportData.count = this.state.cards.length;
        } else if (format === 'themes_only') {
          exportData.themes = this.state.favoriteThemes;
          exportData.currentTheme = this.state.theme;
        }
        
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
        const anchor = document.createElement('a');
        const timestamp = new Date().toISOString().split('T')[0];
        anchor.setAttribute("href", dataStr);
        anchor.setAttribute("download", `ai_ncards_export_${timestamp}_${format}.json`);
        document.body.appendChild(anchor);
        anchor.click(); anchor.remove();
        this.showToast(`Exported ${format} data`);
      }

      // 9. Enhanced Import Function
      importData(input) {
        const file = input.files[0]; 
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const imported = JSON.parse(e.target.result);
            
            // Handle different export formats
            if (imported.version === '2.0' && imported.data) {
              // Full backup import
              this.state = imported.data;
              this.showToast("Full backup imported");
            } else if (imported.cards && Array.isArray(imported.cards)) {
              // Cards only import
              const newCards = imported.cards.map(card => ({
                ...card,
                id: crypto.randomUUID() // Regenerate IDs to avoid conflicts
              }));
              this.state.cards.push(...newCards);
              this.showToast(`Imported ${newCards.length} cards`);
            } else if (imported.themes && Array.isArray(imported.themes)) {
              // Themes import
              this.state.favoriteThemes.push(...imported.themes);
              if (imported.currentTheme) {
                this.state.theme = { ...this.state.theme, ...imported.currentTheme };
              }
              this.showToast(`Imported ${imported.themes.length} themes`);
            } else {
              // Legacy format or unknown
              alert("Unknown import format. Trying to load as legacy format...");
              this.state = imported;
            }
            
            this.save(); 
            this.applyTheme(); 
            this.render();
            document.getElementById('settingsModal').style.display = 'none';
            
          } catch(err) {
            alert("Invalid JSON file: " + err.message);
          }
        };
        reader.readAsText(file);
      }

      // 10. Render Favorite Themes in Settings
      renderFavoriteThemes() {
        const container = document.getElementById('favoriteThemesList');
        if (!container) return;
        
        if (this.state.favoriteThemes.length === 0) {
          container.innerHTML = '<div style="color: #888; font-size: 12px; padding: 10px; text-align: center;">No favorite themes yet</div>';
          return;
        }
        
        let html = '<div style="display: grid; gap: 8px; margin-top: 10px;">';
        
        this.state.favoriteThemes.forEach((theme, index) => {
          const date = theme.savedAt ? new Date(theme.savedAt).toLocaleDateString() : 'Unknown';
          html += `
            <div class="ai-option" style="display: flex; justify-content: space-between; align-items: center;">
              <div>
                <div class="ai-option-title">${theme.savedName || theme.name}</div>
                <div class="ai-option-desc">Saved: ${date}</div>
              </div>
              <div style="display: flex; gap: 5px;">
                <button class="toggle-btn" onclick="app.applyFavoriteTheme(${index})" title="Apply">
                  <i class="fas fa-paint-brush" style="font-size: 10px;"></i>
                </button>
                <button class="toggle-btn" onclick="app.deleteFavoriteTheme(${index})" title="Delete">
                  <i class="fas fa-trash" style="font-size: 10px;"></i>
                </button>
              </div>
            </div>
          `;
        });
        
        html += '</div>';
        container.innerHTML = html;
      }

      // ========== ENHANCED STREAM HANDLING ==========

      async sendRequestForSplit(prompt, tempId, originalCardId) {
        const proxy = this.getProxy();
        this.streamId = tempId;
        
        try {
          const response = await fetch(proxy, {
            method: 'POST', 
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt })
          });
          
          if (!response.ok) throw new Error("Proxy Error");
          const reader = response.body.getReader();
          let buffer = "", fullText = "";
          
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += this.decoder.decode(value, { stream: true });
            const lines = buffer.split('\n\n');
            buffer = lines.pop() || "";
            
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const jsonStr = line.substring(6);
                if (jsonStr === '[DONE]') continue;
                try {
                  const json = JSON.parse(jsonStr);
                  const chunk = json.choices?.[0]?.delta?.content;
                  if (chunk) {
                    fullText += chunk;
                    this.updateStream(tempId, fullText);
                  }
                } catch (e) {}
              }
            }
          }
          
          this.processSplitResult(fullText, originalCardId, tempId);
          
        } catch (err) {
          const card = this.state.cards.find(c => c.id === tempId);
          if (card) card.r = "Error: " + err.message;
          this.streamId = null;
          this.render();
        }
      }

      processSplitResult(text, originalCardId, tempId) {
        // Remove temp card
        this.state.cards = this.state.cards.filter(c => c.id !== tempId);
        
        // Parse split results
        const cardSections = text.split('---CARD---');
        let createdCards = 0;
        
        cardSections.forEach(section => {
          const titleMatch = section.match(/Title:\s*(.+)/i);
          const contentMatch = section.match(/Content:\s*([\s\S]+)/i);
          
          if (titleMatch && contentMatch) {
            const id = crypto.randomUUID();
            this.state.cards.push({
              id,
              q: titleMatch[1].trim(),
              r: contentMatch[1].trim(),
              style: {},
              sourceCard: originalCardId
            });
            createdCards++;
          }
        });
        
        // If parsing failed, create cards based on paragraphs
        if (createdCards === 0) {
          const paragraphs = text.split('\n\n').filter(p => p.trim().length > 50);
          paragraphs.forEach((para, index) => {
            const id = crypto.randomUUID();
            const firstLine = para.split('\n')[0].substring(0, 50);
            this.state.cards.push({
              id,
              q: `Split Part ${index + 1}: ${firstLine}...`,
              r: para.trim(),
              style: {},
              sourceCard: originalCardId
            });
          });
          createdCards = paragraphs.length;
        }
        
        this.save();
        this.render();
        this.showToast(`Created ${createdCards} cards from split`);
      }

      // ========== MODIFIED EXISTING METHODS ==========

      finalizeStream(id, text) {
        this.streamId = null;
        const card = this.state.cards.find(c => c.id === id);
        if (!card) return;

        let cleanText = text;
        
        // Theme command parsing
        const themeMatch = text.match(/!theme:([^!]+)!/);
        if (themeMatch && !this.state.theme.lock) {
          const parts = themeMatch[1].split(',');
          if (parts.length >= 6) {
            const [n, b, cb, t, br, p] = parts.map(s => s.trim());
            this.state.theme = { name: n, bg: b, cardBg: cb, text: t, border: br, primary: p, lock: false };
            this.applyTheme();
            this.showToast("Theme: " + n);
          }
          cleanText = cleanText.replace(themeMatch[0], '');
        }

        // Check for "save theme" command
        const saveThemeMatch = text.match(/save theme as favorite:?\s*(.+)/i);
        if (saveThemeMatch && !this.state.theme.lock) {
          this.saveCurrentThemeAsFavorite(saveThemeMatch[1].trim());
        }

        // Actions
        if (text.includes('!action:view:grid!')) this.setView('grid');
        if (text.includes('!action:view:list!')) this.setView('list');
        if (text.includes('!action:clear!')) { this.state.cards = []; this.save(); this.render(); return; }

        // Extract content
        const newReq = cleanText.match(/New Request:\s*(.+)/i);
        const newRes = cleanText.match(/New Response:\s*(.+)/i);

        if (newReq) { card.q = newReq[1].trim(); cleanText = cleanText.replace(newReq[0], ''); }
        if (newRes) { card.r = newRes[1].trim(); cleanText = cleanText.replace(newRes[0], ''); }
        
        const stripped = cleanText.replace(/!([^!]+)!/g, '').trim();
        
        if (stripped.length > 0 && !newRes) {
          card.r = stripped;
        }

        this.save();
        this.render();
        this.showToast("Done");
      }

      confirmPrompt() {
        const val = document.getElementById('promptText').value.trim();
        if (!val) return;
        document.getElementById('promptModal').style.display = 'none';

        if (this.forceApplyTheme(val)) return;

        if (this.promptContext?.type === 'edit') {
          const card = this.state.cards.find(c => c.id === this.promptContext.id);
          if (card) {
            if (this.promptContext.target === 'q') card.q = val;
            if (this.promptContext.target === 'r') card.r = val;
            this.save(); this.render();
          }
        } else if (this.promptContext?.type === 'rename') {
          this.state.theme.name = val; this.applyTheme(); this.save();
        } else if (this.promptContext?.type === 'saveTheme') {
          this.saveCurrentThemeAsFavorite(val);
        } else if (this.promptContext?.type === 'ai') {
          const card = this.state.cards.find(c => c.id === this.promptContext.id);
          if (card) this.sendRequest(`Change current content to: ${val}`, card.id);
        } else if (this.promptContext?.type === 'continue') {
          const card = this.state.cards.find(c => c.id === this.promptContext.id);
          if (card) this.sendRequest(`Continue: ${val}`, card.id);
        } else {
          this.sendRequest(val);
        }
        this.promptContext = null;
      }

      // ========== REST OF THE METHODS (unchanged but included for completeness) ==========

      pushHistory(action) {
        if (this.history.length > 5) this.history.shift();
        this.history.push(JSON.parse(JSON.stringify(this.state)));
        this.showToast(action);
      }

      undo() {
        if (this.history.length === 0) return;
        this.state = this.history.pop();
        this.applyTheme();
        this.render();
        this.showToast("Undone");
      }

      showToast(msg) {
        const t = document.getElementById('toast');
        t.textContent = msg;
        t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 2000);
      }

      applyTheme() {
        const t = this.state.theme;
        const r = document.documentElement.style;
        r.setProperty('--bg', t.bg);
        r.setProperty('--card-bg', t.cardBg);
        r.setProperty('--text', t.text);
        r.setProperty('--border', t.border);
        r.setProperty('--primary', t.primary);
        document.getElementById('brandName').textContent = t.name || "ai-Ncards";
        
        document.body.className = '';
        if (this.state.settings.view === 'grid') document.body.classList.remove('view-list');
        else document.body.classList.add('view-list');

        const lockBtn = document.getElementById('lockBtn');
        if(lockBtn) lockBtn.textContent = t.lock ? "Unlock" : "Lock";
        if(lockBtn) lockBtn.classList.toggle('active', t.lock);
      }

      applyThemePreset(name) {
        if (this.state.theme.lock) { this.showToast("Theme Locked"); return; }
        
        const presets = {
          'dracula': { bg: '#282a36', cardBg: '#44475a', text: '#f8f8f2', border: '#6272a4', primary: '#ff79c6', name: 'Dracula' },
          'solarized': { bg: '#002b36', cardBg: '#073642', text: '#839496', border: '#586e75', primary: '#b58900', name: 'Solarized' },
          'matrix': { bg: '#000000', cardBg: '#0d0d0d', text: '#00ff00', border: '#003300', primary: '#00ff00', name: 'Matrix' },
          'light': { bg: '#f5f5f5', cardBg: '#ffffff', text: '#222222', border: '#e0e0e0', primary: '#d32f2f', name: 'Light' }
        };

        if (presets[name]) {
          this.state.theme = { ...this.state.theme, ...presets[name], lock: false };
          this.applyTheme();
          this.save();
          this.showToast("Applied: " + name);
        }
      }

      forceApplyTheme(inputStr) {
        if (this.state.theme.lock) return false;

        const match = inputStr.toLowerCase().match(/apply theme (.+)/);
        if (!match) return false;

        const themeName = match[1].trim();
        
        if (['dracula', 'solarized', 'matrix', 'light', 'dark'].includes(themeName)) {
          this.applyThemePreset(themeName);
          return true;
        }

        if (themeName.startsWith('#')) {
          this.state.theme.bg = themeName;
          this.state.theme.cardBg = themeName;
          this.state.theme.text = '#ffffff';
          this.state.theme.border = '#444444';
          this.state.theme.primary = '#ff0000';
          this.state.theme.name = themeName;
          this.applyTheme();
          this.save();
          this.showToast("Custom Theme: " + themeName);
          return true;
        }
        
        if (['red', 'blue', 'green', 'purple', 'orange'].includes(themeName)) {
          const colors = {
            red: { bg: '#1a0000', cardBg: '#4d0000', text: '#ffcccc', border: '#990000', primary: '#ff3333' },
            blue: { bg: '#00001a', cardBg: '#00004d', text: '#ccccff', border: '#000099', primary: '#3333ff' },
            green: { bg: '#001a00', cardBg: '#004d00', text: '#ccffcc', border: '#009900', primary: '#33ff33' }
          };
          if (colors[themeName]) {
            this.state.theme = { ...this.state.theme, ...colors[themeName], name: themeName.toUpperCase() };
            this.applyTheme(); this.save(); return true;
          }
        }
        return false;
      }

      toggleThemeMode() {
        if (this.state.theme.lock) { this.showToast("Theme Locked"); return; }
        const isDark = this.state.theme.bg === '#121212' || (parseInt(this.state.theme.bg.replace('#',''), 16) < 0x777777);
        if (isDark) {
          this.state.theme = { ...this.state.theme, name: "Light Mode", bg: '#f8f9fa', cardBg: '#ffffff', text: '#222222', border: '#e0e0e0' };
        } else {
          this.state.theme = { ...this.state.theme, name: "Dark Mode", bg: '#121212', cardBg: '#1e1e1e', text: '#f5f5f5', border: '#333333' };
        }
        this.applyTheme(); this.save();
      }

      toggleThemeLock() {
        this.state.theme.lock = !this.state.theme.lock;
        this.applyTheme(); this.save();
        this.showToast(this.state.theme.lock ? "Theme Locked" : "Theme Unlocked");
      }

      render() {
        const grid = document.getElementById('grid');
        if (this.state.cards.length === 0) {
          grid.innerHTML = `<div style="text-align:center; padding-top:50px; color:var(--text); opacity:0.5; width:100%; grid-column: 1/-1;">
            <h3>AI-Ncards Pro</h3>
            <p>• Select 2+ cards for AI merge suggestions<br>• Long press a card for split options<br>• Use "save theme as favorite: [name]"</p>
          </div>`;
          return;
        }
        
        if (!this.isStreamingUpdate) grid.innerHTML = '';

        this.state.cards.forEach(c => {
          let card = document.querySelector(`.flip-card[data-id="${c.id}"]`);
          const mustRebuild = !card || card.innerHTML === "";

          if (mustRebuild || !this.isStreamingUpdate) {
            if (!card) {
              card = document.createElement('div');
              card.className = 'flip-card';
              card.dataset.id = c.id;

              card.addEventListener('click', (e) => {
                if (e.target.closest('.card-actions')) return;
                if (this.selected.size > 0) { this.toggleSelect(c.id, e); return; }
                card.classList.toggle('flipped');
              });

              card.addEventListener('dblclick', (e) => {
                const target = e.target.closest('.card-content');
                if (!target) return;
                e.stopPropagation();
                const isFront = target.parentElement.dataset.face === 'front';
                this.promptContext = { type: 'edit', id: c.id, target: isFront ? 'q' : 'r' };
                this.showPromptModal(isFront ? "Edit Request" : "Edit Response", isFront ? c.q : c.r);
              });

              let pressTimer;
              card.addEventListener('touchstart', () => { 
                pressTimer = setTimeout(() => this.openMenu(c.id), 800); // Longer for split options
              });
              card.addEventListener('touchend', () => clearTimeout(pressTimer));

              grid.appendChild(card);
            }

            let contentBack = this.md(c.r);
            if (c.r === '...' && this.streamId === c.id) {
              contentBack = `<span class="thinking">Thinking... <button class="stop-btn" onclick="app.stopStream()">STOP</button></span> <span class="cursor"></span>`;
            }

            card.innerHTML = `
              <div class="flip-card-inner">
                <div class="flip-card-face front" data-face="front">
                  <div class="card-header">
                    <span>REQUEST</span>
                    <div class="card-actions">
                      <i class="fas fa-check" onclick="app.toggleSelect('${c.id}', event)"></i>
                      <i class="fas fa-ellipsis-h" onclick="app.openMenu('${c.id}', event)"></i>
                    </div>
                  </div>
                  <div class="card-content">${this.md(c.q)}</div>
                </div>
                <div class="flip-card-face back" data-face="back">
                  <div class="card-header">
                    <span>RESPONSE</span>
                    <div class="card-actions">
                      <i class="fas fa-redo-alt" onclick="app.replay('${c.id}', event)" title="Replay"></i>
                      <i class="fas fa-volume-up" onclick="app.speak('${c.id}', event)"></i>
                      <i class="fas fa-ellipsis-h" onclick="app.openMenu('${c.id}', event)"></i>
                    </div>
                  </div>
                  <div class="card-content">${contentBack}</div>
                </div>
              </div>
            `;
          }

          const f = card.querySelector('.front');
          const b = card.querySelector('.back');
          if (c.style) {
            if (c.style.bg) { f.style.background = c.style.bg; b.style.background = c.style.bg; }
            if (c.style.color) { f.style.color = c.style.color; b.style.color = c.style.color; }
          }

          if (this.selected.has(c.id)) {
            card.style.borderColor = 'var(--primary)';
            card.style.boxShadow = '0 0 0 2px var(--primary)';
          } else {
            card.style.borderColor = 'var(--border)';
            card.style.boxShadow = 'none';
          }
        });

        const bar = document.getElementById('selectionBar');
        bar.style.display = this.selected.size > 0 ? 'flex' : 'none';
        if (this.selected.size > 0) document.getElementById('selectCount').textContent = this.selected.size;

        this.isStreamingUpdate = false;
      }

      replay(id, e) {
        if (e) e.stopPropagation();
        const card = this.state.cards.find(c => c.id === id);
        if (!card || !card.r || card.r === '...') return;

        const original = card.r;
        card.r = '...';
        this.isStreamingUpdate = true;
        this.render();

        let i = 0;
        const el = document.querySelector(`.flip-card[data-id="${id}"] .back .card-content`);
        
        const interval = setInterval(() => {
          if (i < original.length) {
            const chunk = original.substring(0, i + 1);
            card.r = chunk;
            if (el) {
              el.innerHTML = this.md(chunk) + `<span class="cursor"></span>`;
              el.scrollTop = el.scrollHeight;
            }
            if (this.fsId === id && document.getElementById('fullscreenOverlay').style.display === 'flex') {
              const fs = document.getElementById('fsContent');
              fs.innerHTML = this.md(chunk);
              fs.scrollTop = fs.scrollHeight;
            }
            i++;
          } else {
            clearInterval(interval);
            card.r = original;
            this.isStreamingUpdate = true;
            this.render();
          }
        }, 20);
      }

      toggleSelect(id, e) {
        if (e) e.stopPropagation();
        if (this.selected.has(id)) this.selected.delete(id);
        else this.selected.add(id);
        this.render();
      }

      clearSelection() { this.selected.clear(); this.render(); }

      bulkDelete() {
        this.pushHistory("Bulk Delete");
        this.state.cards = this.state.cards.filter(c => !this.selected.has(c.id));
        this.selected.clear(); this.save(); this.render();
      }

      // Modified bulkMerge to use enhanced version
      bulkMerge() {
        if (this.selected.size < 2) return this.showToast("Select 2+");
        this.showMergeOptions();
      }

      openMenu(id, e) {
        if (e) e.stopPropagation();
        this.menuTarget = id;
        const menu = document.getElementById('cardMenu');
        
        // Update menu for enhanced options
        const isSingleSelected = this.selected.size === 1 && this.selected.has(id);
        const splitBtn = menu.querySelector('[data-act="split"]');
        if (splitBtn) {
          splitBtn.innerHTML = isSingleSelected ? 
            '<i class="fas fa-cut" style="margin-right: 8px;"></i> Split Card (AI Options)' : 
            '<i class="fas fa-cut" style="margin-right: 8px;"></i> Split Card';
        }
        
        let x = (e && e.clientX) || window.innerWidth / 2;
        let y = (e && e.clientY) || window.innerHeight / 2;
        if (x + 180 > window.innerWidth) x = window.innerWidth - 190;
        if (y + 250 > window.innerHeight) y = window.innerHeight - 260;
        menu.style.display = 'block'; menu.style.left = x + 'px'; menu.style.top = y + 'px';
      }

      speak(id, e) {
        if (e) e.stopPropagation();
        const card = this.state.cards.find(c => c.id === id);
        if (!card || !card.r || card.r === '...') return;
        const txt = card.r.replace(/[#*_`>~-]/g, '').substring(0, 2000);
        if (window.responsiveVoice && window.responsiveVoice.speak) {
          if (window.responsiveVoice.isPlaying()) window.responsiveVoice.cancel();
          else window.responsiveVoice.speak(txt, "US English Female", { rate: 1.1 });
        } else if ('speechSynthesis' in window) {
          window.speechSynthesis.cancel();
          window.speechSynthesis.speak(new SpeechSynthesisUtterance(txt));
        }
      }

      getProxy() {
        const val = document.getElementById('proxyInput')?.value.trim();
        if (val) { this.state.settings.proxy = val; this.save(); return val; }
        return this.state.settings.proxy || 'https://ai-proxy.ai-n.workers.dev/api/generate';
      }

      async sendRequest(prompt, targetId = null) {
        if (this.forceApplyTheme(prompt)) return;

        const proxy = this.getProxy();
        
        if (!targetId) {
          const id = crypto.randomUUID();
          this.state.cards.push({ id, q: prompt, r: "...", style: {} });
          targetId = id;
          this.save(); 
          this.render();
          
          setTimeout(() => {
            const el = document.querySelector(`.flip-card[data-id="${id}"]`);
            if (el) {
              el.classList.add('flipped');
              el.scrollTop = el.scrollHeight;
            }
          }, 100);
        } else {
          const card = this.state.cards.find(c => c.id === targetId);
          if (card) card.r = "...";
          this.render();
        }

        this.streamId = targetId;

        const sysPrompt = `You are a visual AI assistant. 
        - Keep text concise. 
        - Use !theme:Name,Bg,CardBg,Text,Border,Primary! to change theme (Hex codes). 
        - Use "save theme as favorite: [name]" to save current theme.
        - Use !action:clear! to clear screen. 
        - Use !action:view:grid! or !action:view:list! to change layout. 
        - Use 'New Request: ...' to edit the top text. 
        - Use 'New Response: ...' to edit the bottom text.
        - For merge suggestions, provide 3 clear options.
        - For split suggestions, provide logical splitting strategies.`;

        try {
          const response = await fetch(proxy, {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt: sysPrompt + "\n\nUser Request: " + prompt })
          });
          if (!response.ok) throw new Error("Proxy Error");
          const reader = response.body.getReader();
          let buffer = "", fullText = "";

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += this.decoder.decode(value, { stream: true });
            const lines = buffer.split('\n\n');
            buffer = lines.pop() || "";
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const jsonStr = line.substring(6);
                if (jsonStr === '[DONE]') continue;
                try {
                  const json = JSON.parse(jsonStr);
                  const chunk = json.choices?.[0]?.delta?.content;
                  if (chunk) {
                    fullText += chunk;
                    this.updateStream(targetId, fullText);
                  }
                } catch (e) {}
              }
            }
          }
          this.finalizeStream(targetId, fullText);
        } catch (err) {
          const card = this.state.cards.find(c => c.id === targetId);
          if (card) card.r = "Error: " + err.message;
          this.streamId = null;
          this.render();
        }
      }

      updateStream(id, text) {
        const card = this.state.cards.find(c => c.id === id);
        if (card) {
          card.r = text;
          const cleanUI = text.replace(/!([^!]+)!/g, '').trim();
          const displayText = cleanUI.length > 0 ? cleanUI : text;

          const el = document.querySelector(`.flip-card[data-id="${id}"] .back .card-content`);
          if (el) { 
            el.innerHTML = this.md(displayText) + (cleanUI.length > 0 ? `<span class="cursor"></span>` : ''); 
            el.scrollTop = el.scrollHeight; 
          }
          
          if (this.fsId === id && document.getElementById('fullscreenOverlay').style.display === 'flex') {
            const fsEl = document.getElementById('fsContent');
            fsEl.innerHTML = this.md(displayText);
            fsEl.scrollTop = fsEl.scrollHeight;
          }

          const grid = document.getElementById('grid');
          if (grid.scrollTop + grid.clientHeight + 200 > grid.scrollHeight) grid.scrollTop = grid.scrollHeight;
        }
      }

      stopStream() {
        this.streamId = null;
        this.render();
      }

      showPromptModal(title, content) {
        document.getElementById('promptTitle').textContent = title;
        document.getElementById('promptText').value = content;
        document.getElementById('promptModal').style.display = 'flex';
        setTimeout(() => document.getElementById('promptText').focus(), 50);
      }

      openFS(id) {
        this.fsId = id; this.fsFlipped = false;
        const card = this.state.cards.find(c => c.id === id);
        if (!card) return;
        const cont = document.getElementById('fsContent');
        cont.innerHTML = this.md(card.r);
        document.getElementById('fullscreenOverlay').style.display = 'flex';
        setTimeout(() => { cont.scrollTop = cont.scrollHeight; }, 50);
      }

      closeFS() { 
        document.getElementById('fullscreenOverlay').style.display = 'none'; 
        this.fsId = null; 
      }

      fsFlip() {
        if (!this.fsId) return;
        const card = this.state.cards.find(c => c.id === this.fsId);
        const cont = document.getElementById('fsContent');
        this.fsFlipped = !this.fsFlipped;
        cont.innerHTML = this.md(this.fsFlipped ? card.q : card.r);
        cont.scrollTop = 0;
      }

      fsRead() { if (this.fsId) this.speak(this.fsId); }

      setView(view) {
        this.state.settings.view = view;
        this.save(); this.applyTheme();
        this.showToast(`View: ${view}`);
      }

      clearAllCards() {
        if (confirm("Delete all cards?")) {
          this.pushHistory("Clear All Cards");
          this.state.cards = [];
          this.save(); this.render();
          document.getElementById('settingsModal').style.display = 'none';
        }
      }

      factoryReset() {
        if (confirm("Factory Reset: Wipe all data?")) {
          localStorage.removeItem('ai_ncards_v2');
          location.reload();
        }
      }

      md(text) {
        if (!text) return '';
        try { return DOMPurify.sanitize(marked.parse(text)); } catch { return text; }
      }

      // New method to show merge options
      showMergeOptions() {
        const modal = document.getElementById('aiOptionsModal');
        if (!modal) {
          this.createAiOptionsModal();
          this.showMergeOptions();
          return;
        }
        
        document.getElementById('aiOptionsTitle').textContent = 'Merge Options';
        const body = document.getElementById('aiOptionsBody');
        
        body.innerHTML = `
          <div class="ai-option" onclick="app.aiMergeSuggestions()">
            <div class="ai-option-title">Get AI Suggestions</div>
            <div class="ai-option-desc">AI will suggest 3 different ways to merge ${this.selected.size} selected cards</div>
          </div>
          
          <div class="ai-option" onclick="app.executeAiMerge('cohesive')">
            <div class="ai-option-title">Merge Cohesively</div>
            <div class="ai-option-desc">Create one well-structured card combining all content</div>
          </div>
          
          <div class="ai-option" onclick="app.executeAiMerge('summary')">
            <div class="ai-option-title">Create Summary</div>
            <div class="ai-option-desc">Extract key points into a concise summary card</div>
          </div>
          
          <div class="ai-option" onclick="app.executeAiMerge('thematic')">
            <div class="ai-option-title">Merge by Theme</div>
            <div class="ai-option-desc">Group content thematically and organize</div>
          </div>
          
          <div style="margin-top: 15px; font-size: 11px; color: #888; text-align: center;">
            ${this.selected.size} cards selected
          </div>
        `;
        
        modal.style.display = 'flex';
      }

      // New method to show split options
      showSplitOptions(cardId) {
        const modal = document.getElementById('aiOptionsModal');
        if (!modal) {
          this.createAiOptionsModal();
          this.showSplitOptions(cardId);
          return;
        }
        
        document.getElementById('aiOptionsTitle').textContent = 'Split Options';
        const body = document.getElementById('aiOptionsBody');
        const card = this.state.cards.find(c => c.id === cardId);
        
        body.innerHTML = `
          <div class="ai-option" onclick="app.aiSplitSuggestions('${cardId}')">
            <div class="ai-option-title">Get AI Suggestions</div>
            <div class="ai-option-desc">AI will suggest 3 different ways to split this card</div>
          </div>
          
          <div class="ai-option" onclick="app.executeAiSplit('${cardId}', 'by_topic')">
            <div class="ai-option-title">Split by Topic</div>
            <div class="ai-option-desc">Divide content by different subjects mentioned</div>
          </div>
          
          <div class="ai-option" onclick="app.executeAiSplit('${cardId}', 'chronological')">
            <div class="ai-option-title">Split Chronologically</div>
            <div class="ai-option-desc">Divide by sequence or timeline</div>
          </div>
          
          <div class="ai-option" onclick="app.executeAiSplit('${cardId}', 'by_importance')">
            <div class="ai-option-title">Split by Importance</div>
            <div class="ai-option-desc">Separate main points from details</div>
          </div>
          
          <div class="ai-option" onclick="app.executeAiSplit('${cardId}', 'question_based')">
            <div class="ai-option-title">Split into Q&A</div>
            <div class="ai-option-desc">Create question-answer pairs from content</div>
          </div>
          
          <div style="margin-top: 15px; font-size: 11px; color: #888; text-align: center;">
            Splitting: "${card?.q.substring(0, 50)}..."
          </div>
        `;
        
        modal.style.display = 'flex';
      }

      // Create AI options modal if it doesn't exist
      createAiOptionsModal() {
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.id = 'aiOptionsModal';
        modal.innerHTML = `
          <div class="modal" style="max-width: 400px;">
            <div class="modal-header">
              <strong id="aiOptionsTitle">AI Options</strong>
              <button class="btn btn-secondary" onclick="document.getElementById('aiOptionsModal').style.display='none'">X</button>
            </div>
            <div class="modal-body" id="aiOptionsBody" style="max-height: 60vh;">
              <!-- Options will be inserted here -->
            </div>
            <div class="modal-footer">
              <button class="btn btn-secondary" onclick="document.getElementById('aiOptionsModal').style.display='none'">Cancel</button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      }

      bindEvents() {
        const input = document.getElementById('userInput');
        const send = () => { 
          if (input.value.trim()) { 
            this.sendRequest(input.value.trim()); 
            input.value = ''; 
          } 
        };
        input.addEventListener('keydown', (e) => { if (e.key === 'Enter') send(); });
        document.getElementById('sendBtn').onclick = send;

        document.getElementById('settingsBtn').onclick = () => {
          document.getElementById('proxyInput').value = this.state.settings.proxy || '';
          document.getElementById('settingsModal').style.display = 'flex';
          this.renderFavoriteThemes();
        };
        
        document.getElementById('undoBtn').onclick = () => this.undo();
        document.getElementById('brandName').onclick = () => {
          this.promptContext = { type: 'rename' };
          this.showPromptModal("Rename Brand", this.state.theme.name);
        };

        document.getElementById('cardMenu').addEventListener('click', (e) => {
          const act = e.target.closest('[data-act]')?.dataset.act;
          if (!act || !this.menuTarget) return;
          document.getElementById('cardMenu').style.display = 'none';
          const card = this.state.cards.find(c => c.id === this.menuTarget);

          switch(act) {
            case 'continue': 
              this.promptContext = { type: 'continue', id: this.menuTarget }; 
              this.showPromptModal("Continue", ""); 
              break;
            case 'ai-edit': 
              this.promptContext = { type: 'ai', id: this.menuTarget }; 
              this.showPromptModal("Magic Action", ""); 
              break;
            case 'split':
              this.showSplitOptions(this.menuTarget);
              break;
            case 'style':
              if (card) {
                if (!card.style) card.style = {};
                const bg = prompt("Background (hex/name):"); if(bg) card.style.bg = bg;
                const col = prompt("Text Color:"); if(col) card.style.color = col;
                this.save(); this.render();
              } 
              break;
            case 'copy': 
              navigator.clipboard.writeText(card.r); 
              this.showToast("Copied"); 
              break;
            case 'fs': 
              this.openFS(this.menuTarget); 
              break;
            case 'delete':
              this.pushHistory("Delete");
              this.state.cards = this.state.cards.filter(c => c.id !== this.menuTarget);
              this.save(); this.render(); 
              break;
          }
        });

        window.onclick = (e) => {
          if (e.target.classList.contains('modal-overlay')) e.target.style.display = 'none';
          if (!e.target.closest('#cardMenu')) document.getElementById('cardMenu').style.display = 'none';
        };

        document.getElementById('grid').addEventListener('scroll', () => {
          document.getElementById('cardMenu').style.display = 'none';
        });
        
        // Create AI options modal on load
        setTimeout(() => this.createAiOptionsModal(), 100);
      }
    }

    const app = new App();
    window.onload = () => app.init();
  </script>
  
  <!-- HTML Structure -->
  <div id="topBar">
    <div style="display: flex; align-items: center; gap: 8px;">
      <div id="brandName">ai-Ncards Pro</div>
      <button class="btn-icon" id="undoBtn" title="Undo"><i class="fas fa-undo"></i></button>
    </div>
    <div>
      <button class="btn-icon" id="settingsBtn" title="Settings"><i class="fas fa-cog"></i></button>
    </div>
  </div>
  
  <div id="selectionBar">
    <div id="selectCount">0</div>
    <div class="actions">
      <button onclick="app.bulkMerge()">AI Merge</button>
      <button onclick="app.clearSelection()">Cancel</button>
      <button class="danger" onclick="app.bulkDelete()">Delete</button>
    </div>
  </div>
  
  <div id="grid"></div>
  
  <div id="inputPanel">
    <input type="text" id="userInput" placeholder="Type to create or use AI commands..." autocomplete="off">
    <button id="sendBtn"><i class="fas fa-arrow-up"></i></button>
  </div>
  
  <div id="cardMenu">
    <button data-act="continue">Continue / Refine</button>
    <button data-act="ai-edit">Magic Action (AI)</button>
    <button data-act="split">Split Card</button>
    <button data-act="style">Style</button>
    <button data-act="copy">Copy</button>
    <button data-act="fs">Fullscreen</button>
    <button data-act="delete">Delete</button>
  </div>
  
  <div id="fullscreenOverlay">
    <div id="fsHeader">
      <div>
        <button class="btn btn-secondary" onclick="app.fsFlip()">Flip</button>
        <button class="btn btn-secondary" onclick="app.fsRead()">Read</button>
      </div>
      <button class="btn btn-secondary" onclick="app.closeFS()">Close</button>
    </div>
    <div id="fsContent"></div>
  </div>
  
  <!-- Settings Modal -->
  <div class="modal-overlay" id="settingsModal">
    <div class="modal">
      <div class="modal-header">
        <strong>Settings</strong>
        <button class="btn btn-secondary" onclick="document.getElementById('settingsModal').style.display='none'">X</button>
      </div>
      <div class="modal-body">
        <div class="setting-row">
          <label>Proxy URL</label>
          <input type="text" id="proxyInput" placeholder="https://...">
        </div>
        <div class="setting-row">
          <label>View</label>
          <div class="toggle-group">
            <button class="toggle-btn" onclick="app.setView('list')">List</button>
            <button class="toggle-btn" onclick="app.setView('grid')">Grid</button>
          </div>
        </div>
        <div class="setting-row">
          <label>Theme Presets</label>
          <div class="toggle-group">
            <button class="toggle-btn" onclick="app.applyThemePreset('dracula')">Dracula</button>
            <button class="toggle-btn" onclick="app.applyThemePreset('solarized')">Solarized</button>
            <button class="toggle-btn" onclick="app.applyThemePreset('matrix')">Matrix</button>
            <button class="toggle-btn" onclick="app.applyThemePreset('light')">Light</button>
          </div>
          <div style="margin-top:5px; display:flex; gap:5px;">
            <button class="toggle-btn" onclick="app.toggleThemeMode()">Toggle</button>
            <button class="toggle-btn" id="lockBtn" onclick="app.toggleThemeLock()">Lock</button>
            <button class="toggle-btn" onclick="app.saveCurrentThemeAsFavorite()">Save Favorite</button>
          </div>
        </div>
        <div class="setting-row">
          <label>Favorite Themes</label>
          <div id="favoriteThemesList">
            <!-- Favorite themes will be rendered here -->
          </div>
        </div>
        <div class="setting-row">
          <label>Data Management</label>
          <div class="toggle-group">
            <button class="toggle-btn" onclick="app.exportData('full')">Full Export</button>
            <button class="toggle-btn" onclick="app.exportData('cards_only')">Export Cards</button>
            <button class="toggle-btn" onclick="app.exportData('themes_only')">Export Themes</button>
            <button class="toggle-btn" onclick="document.getElementById('importFile').click()">Import</button>
          </div>
          <input type="file" id="importFile" style="display:none" onchange="app.importData(this)" accept=".json">
          <div style="margin-top: 10px; font-size: 11px; color: #888;">
            Import supports: Full backup, Cards only, Themes only
          </div>
          <button class="btn-danger" onclick="app.clearAllCards()">Clear All Cards</button>
          <br><br>
          <button class="btn-danger" onclick="app.factoryReset()">Factory Reset</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Prompt Modal -->
  <div class="modal-overlay" id="promptModal">
    <div class="modal">
      <div class="modal-header">
        <strong id="promptTitle">Action</strong>
        <button class="btn btn-secondary" onclick="document.getElementById('promptModal').style.display='none'">X</button>
      </div>
      <div class="modal-body">
        <textarea id="promptText"></textarea>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="document.getElementById('promptModal').style.display='none'">Cancel</button>
        <button class="btn btn-primary" onclick="app.confirmPrompt()">OK</button>
      </div>
    </div>
  </div>
  
  <div id="toast">Action</div>
</body>
</html>